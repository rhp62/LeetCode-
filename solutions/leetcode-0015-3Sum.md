对于这道leetcode的题目，大家可以先去它的简化版[leetcode-0001-TwoSum](https://blog.csdn.net/wlhr62/article/details/106484164)去热热身

# 1. 题目地址

 - [英文版题目地址](https://leetcode.com/problems/3sum/)
 - [中文版题目地址](https://leetcode-cn.com/problems/3sum/)
# 2. 题目描述
 - **英文描述**

```
Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique 
triplets in the array which gives the sum of zero.

Note: The solution set must not contain duplicate triplets.

Example:

Given array nums = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```

 - **中文描述**

```
给你一个包含n个整数的数组nums，判断nums中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。

示例：

给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```
# 3. 解题思路

 - **常规思路**：一样的情况，遇到这种题目，我们脑海中最先出现的肯定是**暴力枚举**的方法，暴力进行遍历。也就是使用**三层for循环**来遍历，从而找出相加符合目标值的三个元素。这样的话：**时间复杂度=O(n^3)**，**空间复杂度=O(1)**
显然，这种暴力遍历、时间复杂度为O(n^3)的方法肯定不可能是最优解，所以继续想办法优化时间复杂度。
 - **优化思路**：保持数组中每个元素与其索引想对应的最好方法就是**哈希表**(HashMap)，即增加一个 Map来记录我们所遍历的数字及其对应的索引值。然后将求和转化为求差，查找 (target-nums[i]) 是否在哈希表中。哈希表是通过以空间来换时间的方法，最优的情况下可以将查找时间从O(n)降低到O(1)。
 - **优化方法一**：两次遍历的方法，即两次哈希表的方法
   1. 第一次遍历：将每个元素的值和它的索引添加到哈希表中。
   2. 第二次遍历：检查每个元素所对应的目标元素 (target - nums[i]) 是否存在于哈希表中。特别重要的一点是这个目标元素不能是 nums[i] 本身。
   3. 时间复杂度=O(n)，空间复杂度=O(n)
```
优化方法一（优化分析）：

 1. 优化主要是利用了哈希表以空间换时间的特性，即最优情况下可以将查找时间从O(n)降低到O(1)。
 2. 将整个数组中的n个元素遍历两次，先将每个元素和索引存表，再遍历查找目标元素是否在表中，所以时间复杂度是O(n)。
 3. 申请的空间即哈希表中所存储的元素数量，存储的数量就是数组中的n个元素，所以空间复杂度为O(n)。
```
 - **优化方法二**：一次遍历的方法，即遍历的时候一边存表一边查表
   1. 遍历数组中的元素，查询表中是否已经存在当前元素所对应的目标元素 (target-nums[i])，如果存在，那么就已经找到了对应解，立即返回结果，不用再往后执行了。如果不存在，那就进行存表的步骤，继续往下遍历查找，直到查询到目标值。
   2. 时间复杂度=O(n)，空间复杂度=O(n)
```
优化方法二（优化分析）：

 1. 优化主要是利用了哈希表以空间换时间的特性，即最优情况下可以将查找时间从O(n)降低到O(1)。
 2. 只进行一次遍历操作，遍历的同时在表中查询是否出现过目标元素 (target-nums[i])，如果出现过就立即返回。
 3. 时间复杂度是O(n)，申请的空间取决于哈希表中所存储的元素数量，最多只用存储n个元素，空间复杂度为O(n)。
```
# 4. 解题关键
1. 要想到哈希表的结构，以空间换时间，缩短查询时间为O(1)
2. 将求和的问题转化为求差值的方法来解决，即：nums[j] = target - nums[i]
3. 遍历数组中的元素时，边查询边存表，查找到对应解就立即返回结果
# 5. 示例代码
